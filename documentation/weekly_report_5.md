# Weekly report 5

### What I have done during this week?

Sunday was rather lazy day in terms of project work. After last week frustration, I decided to play around again with the current model yet again without improvement. I pretty much came in a conclusion (which can be very wrong) that I can not improve early game without adding better heuristic.

On monday I started working with new heuristic for the bitboards. I had already tried out this earlier without success. This time I managed to create heuristic which counts how many three connects the player has at the certain board configuration. Currently the heuristic value for 3 connects are simply calculated by: number of player 3 connects reduced by number of opponent 3 connects. On top of that I added additional 3 points for each coin placed at the middle column. This is something I need to reinvestigate if it is going to be necessary. I also created move exploration ordering which primarily ranks the move order by heuristic values recieved from the previous iterations and secondarily by the middle column ordering. Finally I recreated transposition table, but again I feel like that needs additional investigation in order to make it work properly. As a result from mondays work the algorithm is playing significantly better early game. It can now search within 5 seconds up to depth 12 in early game while it previously was able to search roughly 14 depths. It can now predict the outcome of the game roughly around round of 20 while it previously was able to find it slightly earlier.

On tuesday I created additional check for finding available columns which cuts the number of available columns if opponent can get victory during next turn ie. if player has to block certain column in order to prevent losing, it makes no sense to investigate other columns further. This allowed to reach one depth further during the early game. That was quite fast implementation and most of the time I spend for creating docstring for bitboard classes as I hadn't done that during the implementations of those classes. I also found out that current iterative deepening Minimax search probably returns too much information as it is now returning also list of all available columns and their heuristic values. This means that I probably do not need to return chosen column number and heuristic value separately. There are however other things to take care and changing this may complicate other stuff, so I am not sure I am going to change that very soon at least.

On wednesday I created checking for the symmetrical game board situations. I assumed that this will be beneficial to narrow down search paths at the early game. I also created additional boolean parameter for the AI class to keep track if the game board has evolved from the symmetrical situation to non-symmetrical situation. There may be some cases when game can actually evolve back to the symmetrical, but I assume that the time saving from not running the symmetrical checks after game has evolved to non-symmetrical will be more beneficial than consider cases where game might evolve back to symmetrical. Anyway this wasn't the game changer for the algorithm. Judging by the few tests, this reduced roughly 10 - 15% of calculation time on a last iteration at the early game. On top of that I did few additional tests for the game service class and updated testing documentation which is still quite an incomplete.

On thursday I started implementing multiprocessing first to the Minimax algorithm, but I did not manage to get it working. I also tried multiprocessing and multithreading to run looped binaryoperations which I actually managed to run without errors, but I ended up using more calculation time instead of benefiting anything. I quite quickle rolled back where I left yesterday and decided to spend time for other things. Most of the time I spend for peer reviewing and state of the actual project did not get any improvement today.

On Friday I decided to take day off from the project and on saturday I spend time on updating the documentation and reports.

### How has the program progressed?

My primary goal from the last week was to solve problem with early game playing. I solved this by adding some heuristics calculations. As results the AI is playing significantly better early game. I also had set other optimisation goals for this week, such as better move exploration ordering, use of transposition table and symmetrical checks. I ended up doing them all, even though I still think that the transposition table implementation is still a bit incomplete.

At the start of this week, iterative deepening algorithm was able to reach up to depth 14 in early game within 5 second time limit and at around round 20 it was able to calculate up to the full remaining depth. Currently the algorithm is performing equally well, but with better early game heuristics. I removed the hard calculation limit (because it complicated the iterative deepening logic and slightly slowed down Minimax) so the precise comparison a bit hard. However, it can now calculate up to depths of 14-15 in early game in less than 5 seconds solve the game at around same round than earlier.

### What did I learn this week?

Last week I mentioned that the binary operations I had implemented where taken pretty much according to the pseudocode examples. This week I had to create new operations for the open three and symmetry checks which means that I yet again know these a least little bit better than previous week. I also very briefly studied multiprocessing and multithreading to solve parallel problems in faster time, but I did not manange to get any improvements with them.

### What was unclear or caused difficulties?

Generally I am still quite uncertain about many of my implementations. I can see that with some of them I can get performance improvements but I am still a bit uncertain if those are implemented properly or not. During this project I have for example created a new implementations which has increased the calculation speed and seemed to be still making good choices, but at some point I have found a clear bug of the implementation. I recall I had this kind of bug at least on a transposition table and perhaps also on move exploration ordering. So my biggest uncertainty is that whenever I create new optimisation is it actually improving the AI or is it skipping some valid paths due some bug. Luckily however, I can use this list matrix algorithm as a benchmark to at least see if the new implementation still beats it or not.

### What do I do next?

I feel like the current AI implementation is already good enough as it is right now. I also know that there won't be any realistic possibility for me to improve it so that I can perfectly solve the whole game starting from the new round. This being said, I will still try to make some minor improvements, such as reworking with transposition table, trying to optimise alpha-beta window and perhaps test little bit multiprocessing again. Most likely I am not going to spend too much time on these optimisation and I will reroll the solution back to previous stage with a small threshold. So ideally I will expect small improvements, but I am not very unsatisfied even though I do not get any improvements at all.

There are still lot's of work left on the documentations and perhaps I will put my primary focus on them. I do not want to end up in the situation where I am not forced to the documentation on a last day just because I have to do them. Instead of that, I want to be in a situation that I can do the optimisation work during the last days on a project if I want to, but not necessarily need to.